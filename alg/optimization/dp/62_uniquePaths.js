/**
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
/**
 * dp
 * - following table can be generated by brute force 
 * 1				     (corresponding to m = 1, n = 1)
 * 1 2					 (corresponding to m = 1, n = 2; m = 2, n = 2)
 * 1 3 6				 (corresponding to m = 1, n = 3; m = 2, n = 3; m = 3, n = 3)
 * 1 4 10 20			
 * 1 5 15 35 70		
 * 1 6 21 56 126 252	
 * 1 7 28 84 210 462 924 (... 1,7; 2,7; ...; 7,7)
 *
 * - observes 2 properties:
 *   1. last element = last 2nd element * 2
 *   2. k-th element at (m,n) = k - 1 th element at (m,n) + k-th element at (m - 1,n)
 * - so dp can work
 * - and time: O(m * n), space O(n)
 */ 
var uniquePaths = function (m, n) {
    let res;
    if (m < n) {
        res = solve(m, n);
    } else {
        res = solve(n, m);
    }

    return res;

    function solve(m, n) {
        const result = [1];

        let i, j;
        for (i = 1; i < n; i++) {
            for (j = 1; j < m; j++) {
                result[j] += result[j - 1];
            }
            result[i] = result[i - 1] * 2;
        }

        return result[m - 1];
    }
}

/**
 * brute force with dfs 
 * - works, since it won't go into a loop
 * - 2 directions (right or bot)
 * - depth of tree = max(m, n)
 * - so O(2 ^ max(m, n))
 */ 
var uniquePaths_slow = function (m, n) {
    let paths;
    paths = 0;
    dfs(1, 1);
    return paths;

    function dfs(i, j) {
        if (i === m && j === n) {
            paths++;
            return;
        } else if (i > m || j > n) {
            return;
        }

        dfs(i, j + 1); // down
        dfs(i + 1, j); // right
    }
};